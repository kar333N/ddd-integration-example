# Пример реализации Domain-Driven Design (DDD) на PHP

Этот репозиторий содержит практический пример реализации концепций Domain-Driven Design (DDD) на языке PHP. Цель проекта - продемонстрировать ключевые паттерны DDD, такие как Ограниченные Контексты, Общее Ядро, Сущности, Объекты-значения, Репозитории, Сервисы, а также различные стратегии интеграции между Ограниченными Контекстами.

## Описание Сценария

Проект моделирует упрощенную систему для управления образовательными курсами, записи студентов на эти курсы и отслеживания их прогресса.

## Ключевые Концепции DDD, продемонстрированные в проекте:

*   **Ограниченные Контексты (Bounded Contexts):**
    *   **`CourseManagement` (Управление Курсами):** Отвечает за создание курсов, управление их содержанием (лекции, названия).
    *   **`StudentEnrollment` (Запись Студентов):** Отвечает за процесс записи студентов на курсы и отслеживание статуса записи.
    *   **`ProgressTracking` (Отслеживание Прогресса):** Отвечает за фиксацию и предоставление информации о прогрессе студентов по лекциям курса.
    *   **`Reporting` (Отчетность):** (Добавлен для демонстрации ACL) Генерирует отчеты, например, о популярности курсов.

*   **Общее Ядро (Shared Kernel):**
    *   Содержит общие для нескольких контекстов объекты-значения, обеспечивающие согласованность:
        *   `CourseId`: Уникальный идентификатор курса.
        *   `StudentId`: Уникальный идентификатор студента.
        *   `LectureId`: Уникальный идентификатор лекции.

*   **Сущности (Entities):**
    *   `Course` (в `CourseManagement`)
    *   `Enrollment` (в `StudentEnrollment`)
    *   `StudentProgress` (в `ProgressTracking`)

*   **Объекты-значения (Value Objects):**
    *   `CourseId`, `StudentId`, `LectureId` (в `SharedKernel`)
    *   `ReportableCourse` (в `Reporting` - специфичная для контекста модель)
    *   `CourseDTO` (в `CourseManagement/PublishedLanguage` - часть Опубликованного Языка)

*   **Репозитории (Repositories):**
    *   Интерфейсы и In-Memory реализации для каждой сущности (`CourseRepository`, `EnrollmentRepository`, `ProgressRepository`).

*   **Сервисы (Services):**
    *   Прикладные сервисы в каждом контексте, координирующие работу с сущностями и репозиториями (`CourseService`, `EnrollmentService`, `ProgressService`, `ReportService`).
    *   `CourseCatalogOHS` (Open-Host Service в `CourseManagement`) для предоставления данных внешним системам.

*   **Паттерны Интеграции Потребитель-Поставщик:**
    *   **Конформист (Conformist):**
        *   **Пример:** Контекст `StudentEnrollment` выступает как конформист по отношению к контексту `CourseManagement`. `EnrollmentService` напрямую использует `CourseManagementRepository` для проверки существования курса, полностью полагаясь на модель курса поставщика.
    *   **Предохранительный слой (Anticorruption Layer - ACL):**
        *   **Пример:** Контекст `Reporting` использует `CourseManagementACL` для взаимодействия с контекстом `CourseManagement`. ACL преобразует внутреннюю модель `Course` из `CourseManagement` в упрощенную модель `ReportableCourse`, специфичную для нужд отчетности, тем самым изолируя `Reporting` от изменений в `CourseManagement`.
    *   **Сервис с Открытым Протоколом (Open-Host Service - OHS) с Опубликованным Языком (Published Language - PL):**
        *   **Пример:** Контекст `CourseManagement` предоставляет `CourseCatalogOHS`. Этот сервис отдает данные во внешние системы (например, `ExternalPartnerCatalog`) в виде `CourseDTO` – это стабильный, упрощенный "опубликованный язык", предназначенный для интеграции. Внутренняя модель `Course` может меняться, но пока OHS может преобразовывать ее в `CourseDTO`, внешние потребители защищены от этих изменений.

## Структура Проекта
```
project-root/
├── composer.json
├── README.md
├── src/
│ ├── SharedKernel/ # Общее ядро
│ │ └── ValueObject/
│ ├── CourseManagement/ # Контекст Управления Курсами
│ │ ├── Entity/
│ │ ├── Repository/
│ │ ├── Service/
│ │ └── PublishedLanguage/ # Опубликованный язык для OHS
│ ├── StudentEnrollment/ # Контекст Записи Студентов
│ │ ├── Entity/
│ │ ├── Repository/
│ │ └── Service/
│ ├── ProgressTracking/ # Контекст Отслеживания Прогресса
│ │ ├── Entity/
│ │ ├── Repository/
│ │ └── Service/
│ └── Reporting/ # Контекст Отчетности
│ ├── ValueObject/ # Модели специфичные для отчетов
│ ├── AntiCorruptionLayer/ # ACL для интеграции с CourseManagement
│ └── Service/
└── public/
└── index.php # Точка входа, демонстрирующая взаимодействие контекстов
```
## Требования

*   PHP >= 8.3
*   Composer

## Установка

1.  Клонируйте репозиторий:
    ```bash
    git clone <URL_репозитория>
    cd <папка_репозитория>
    ```
2.  Установите зависимости:
    ```bash
    composer install
    ```

## Использование

Для демонстрации работы системы запустите скрипт `public/index.php` из командной строки:

```bash
php public/index.php
```

Скрипт выполнит последовательность действий в различных ограниченных контекстах, демонстрируя их создание, взаимодействие и применение паттернов интеграции. Вывод в консоль покажет, какие операции выполняются в каждом контексте.

Цели примера
Показать, как разделить сложный домен на более управляемые Ограниченные Контексты.

Продемонстрировать использование Общего Ядра для обеспечения согласованности.

Привести практические примеры реализации паттернов Конформист, ACL и OHS.

Подчеркнуть важность явного определения моделей и языков внутри каждого контекста и для интеграции.

Этот пример является упрощенной моделью и не предназначен для использования в производственной среде без доработок (например, использование реальных баз данных, полноценная обработка ошибок, аутентификация/авторизация и т.д.).


**Что следует учесть и, возможно, добавить в будущем (или если это уже есть):**

*   **Доменные События (Domain Events):** Если бы вы их использовали для асинхронной интеграции, это стоило бы упомянуть.
*   **Более сложные бизнес-правила:** Сейчас бизнес-логика в сервисах довольно проста.
*   **Тесты:** В реальном проекте были бы юнит-тесты для каждого контекста и, возможно, интеграционные тесты.
*   **Использование интерфейсов для межконтекстного взаимодействия:** Вместо прямого использования репозитория другого контекста (`CourseManagementRepository` в `EnrollmentService`), можно было бы определить интерфейс в `StudentEnrollment`, а `CourseManagement` предоставил бы его реализацию (Adapter). Это уменьшило бы прямую связанность.


